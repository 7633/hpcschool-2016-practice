# Молодежная научная школа "Высокопроизводительные вычисления, оптимизация и приложения". Трек "Робототехника и компьютерное зрение"

## Лабораторная работа "Детектирование объектов с использованием библиотеки OpenCV"

### Цели

__Цель данной лабораторной работы__ состоит в том, чтобы решить одну
из классических задач компьютерного зрения - детектирование объектов -
с использованием средств библиотеки OpenCV. В качестве целевых
объектов для детектирования рассматриваются логотипы ННГУ, OpenCV и Intel.

### Задачи

__Основные задачи__

  1. Разработать приложение, осуществляющее детектирование объектов 
     определенного класса (один из предложенных классов логотипов)
     на одиночном изображении и видео с помощью каскадного классификатора.
  1. Обучить детектор логотипов выбранного класса на основе
     HAAR- и LBP-признаков.
  1. Применить полученные самостоятельно детекторы к тестовому видео.
     Визуально оценить качество детекторов.

__Дополнительные задачи__
  
  1. Разработать приложение, позволяющее детектировать логотипы
     нескольких классов на одном изображении/видео одновременно.
  1. Разработать приложение, осуществляющее детектирование логотипов
     на изображении и видео с помощью HOG-детектора
     (см. документацию [`HOGDescriptor`][hog-documentation]).
  1. Добавить в разработанное приложение возможность оценки качества
     детектирования при наличии файла с описанием истинных положений
     объектов на изображении/кадрах видео.

### Общая схема решения задачи детектирования

Общая схема решения задачи детектирования с использованием машинного обучения
включает два основных этапа.

  1. __Обучение детектора.__ Обучение предполагает выполнение следующих
     действий:

     - Подготовка *тренировочных данных* - множества положительных
       (содержащих объект) и отрицательных (не содержащих объект) примеров
       изображений.
     - Извлечение признаков из каждого изображения тренировочного набора.
     - Обучение детектора на полученном наборе признаков.
     - Сохранение параметров обученной модели.

  1. __Тестирование детектора.__ Тестирование предполагает выполнение
     следующих действий:

     - Получение изображения, на котором необходимо определить положения
       объектов.
     - Извлечение признаков из полученного изображения. На данном этапе
       используется тот же алгоритм, что и при обучении детектора.
     - Передачи построенных признаков детектору, который принимает решение
       о наличии/отсутствии объекта и его местоположении в системе координат
       изображения.
      
### Требования к программному обеспечению

Для выполнения лабораторной работы требуется наличие следующего
программного обеспечения:

  - Библиотеки: [OpenCV 3.1][opencv].
  - Утилиты: [CMake][cmake] 2.8 и выше.
  - Среда разработки: Microsoft Visual Studio 2015 (под Windows)
    или любая другая среда разработки, для которой CMake способен сгенерировать
    файлы для компиляции.
  - [Git-клиент][git-client] (опционально).

### Структура репозитория

Репозиторий содержит следующие директории и файлы:

  - `include` - заголовочные файлы модулей библиотеки `hpc_2016_logo_detection_lib`.
  - `samples` - примеры использования методов. Изначально директория
    содержит шаблонный пример консольного приложения `template_demo.cpp`.
    Лабораторная работа предполагает разработку собственного приложения,
    обеспечивающего решение задачи детектирования на базе указанного шаблона.
  - `src` - исходные файлы модулей библиотеки `hpc_2016_logo_detection_lib`.
  - `data` - директория, содержащая данные, необходимые для решения задачи:

    - `detection/cascades` - xml-файлы, содержащие обученные модели каскадного
      классификатора для логотипов ННГУ, OpenCV и Intel.
    - `detection/negatives` - негативные изображения.
    - `detection/positives` - позитивные изображения детектируемых логотипов.
    - `detection/vec_files` - vec-файлы, содержащие признаковые описания
    - `negatives.txt` - список негативных изображений.
    - `video/logo.mp4` - видео, содержащее сцены с логотипами.

  - `CMakeLists.txt` - общий файл для сборки проектов с помощью CMake.
  - `README.md` - данный файл.
  - `.gitignore`- перечень директорий/файлов, которые игнорируются системой
    контроля версий.

## Общая структура программного модуля

В лабораторной работе основные задачи решаются на базе программного
модуля `detection` библиотеки `hpc_2016_logo_detection_lib`. Модуль
включает заголовочный файл `include\detection.hpp`
и исходный файл`src\detection.cpp`. Модуль содержит объявление
абстрактного класса `Detector`.

```cpp
class Detector {
 public:
  static std::shared_ptr<Detector> CreateDetector(const std::string& name);
  virtual bool Init(const std::string& model_file_path) = 0;
  virtual void Detect(const cv::Mat& frame, std::vector<cv::Rect>& objects,
                      std::vector<double>& scores) = 0;
};
```

Класс имеет следующие чисто виртуальные методы:

  1. `Init` - метод загрузки детектора из файла.
  1. `Detect` - метод детектирования объектов на одиночном изображении.
     Входные параметры: `frame` - изображение.
     Выходные параметры: `objects` - вектор прямоугольников,
     выделяющих найденные объекты на изображении;
     `scores` - вектор, содержащий для каждого срабатывания детектора число,
     определяющее уверенность детектора в наличии объекта 
     в соответствующей области изображения.

Также класс содержит [фабричный метод][factory-method] `CreateDetector`.

### Сборка проекта с помощью CMake и Microsoft Visual Studio 2015

В данном разделе описана типичная последовательность действий, которую
необходимо выполнить для сборки проекта с использованием утилиты CMake и
Microsoft Visual Studio 2015. Далее для определенности выполняется сборка проекта
`hpc_2016_logo_detection`.

  1. Рядом с директорией проекта `hpcschool-2016-practice` создайте
     `hpcschool-2016-practice-build`. В новой директории будут размещены файлы
     решения и проектов, сгенерированные с помощью CMake.

     ```bash
     $ mkdir hpcschool-2016-practice-build
     ```

  1. Перейдите в директорию `hpcschool-2016-practice-build`:

     ```bash
     $ cd ./hpcschool-2016-practice-build
     ```

  1. Сгенерируйте файлы решения и проектов с помощью утилиты CMake. Для этого
     можно воспользоваться графическим приложением, входящим в состав
     утилиты, либо выполнить следующую команду:

  ```bash
  $ cmake -DOpenCV_DIR="<OpenCVConfig.cmake-path>" -G <generator-name> <path-to-hpcschool-2016-practice>
  # <OpenCVConfig.cmake-path> - директория, в которой установлена
  #     библиотека OpenCV и расположен файл OpenCVConfig.cmake
  #     в терминал-классе это директория c:\OpenCV31\opencv\build
  # <generator-name> - название генератора, в случае тестовой
  #     инфраструктуры участников школы может быть "Visual Studio 14 2015 Win64"
  #     (если в командной строке набрать cmake без параметров, то можно просмотреть
  #     список доступных генераторов)
  # <path-to-hpcschool-2016-practice> - путь до директории
  #     hpcschool-2016-practice, где лежат исходные коды проекта (если предыдущие действия
  #     выполнены корректно, то это директория`../hpcschool-2016-practice`)
  ```
  Обратите внимание, что для сборки проекта необходима версия OpenCV 3.1.x,
  например, 3.1.0, которую можно скачать [здесь](http://opencv.org/downloads.html).
  В терминал-классах OpenCV 3.1.0 установлена в директорию `C:\OpenCV31`

  1. Откройте сгенерированный файл решения `hpc_2016_logo_detection.sln`.
     В терминал-классах Microsoft Visual Studio располагается по пути:
     `C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\devenv.exe`
  1. Нажмите правой кнопкой мыши по проекту `ALL_BUILD` и выберите пункт
     `Rebuild` контекстного меню, чтобы собрать решение. В результате все
     бинарные файлы будут размещены в директории
     `hpcschool-2016-practice-build/bin`, библиотеки - `hpcschool-2016-practice-build/lib`.
  1. Для запуска приложения откройте командную строку (`cmd.exe` в `Пуск`)
     и перейдите в директорию с бинарными файлами, используя команду `cd`.
  1. Можно запустить шаблонное приложение `template_demo.exe`. Возможное сообщение
     при запуске: `The program can't start because
     opencv_world310d.dll is missing from your computer. Try reinstalling
     the program to fix this problem.`. Решение 1: скопировать
     соответствующую библиотеку из `C:\OpenCV31\opencv\build\x64\vc14\bin`
     к бинарным файлам проекта. Решение 2: добавить путь `C:\OpenCV31\opencv\build\x64\vc14\bin`
     в переменную окружения `PATH`. Замечание: если сборка проекта производилась
     в Release-конфигурации, то данная библиотека называется `opencv_world310.dll`.

### Детальная инструкция по выполнению работы

  1. Дополнить заголовочный файл `include\detection.hpp` объявлением 
     класса `CascadeDetector`, унаследовав его от класса `Detector`.

  ```cpp
  class CascadeDetector : public Detector {
  public:
    virtual bool Init(const std::string& model_file_path);
    virtual void Detect(const cv::Mat& frame, std::vector<cv::Rect>& objects,
                        std::vector<double>& scores);

  protected:
    cv::CascadeClassifier detector;
  };
  ```
  
     Замечания:
       - `cv::CascadeClassifier` - класс библиотеки OpenCV, используемый
         для представления сущности каскадного классификатора. Указанный класс объявлен
         в заголовочном файле `opencv2/objdetect/objdetect.hpp`.
       - `cv::Mat` - тип данных библиотеки OpenCV, используемый для хранения
         изображений.
       - `cv::Rect` - тип данных библиотеки OpenCV, используемый для преставления
         прямоугольника.

  1. Добавить код для создания экземпляра класса `CascadeDetector` в фабричный метод
     `Detector::CreateDetector`.

  ```cpp
  if (name == "cascade") {
    return std::make_shared<CascadeDetector>();
  }
  ```

  1. Реализовать метод `CascadeDetector::Init`. Метод предполагает
     выполнение следующей последовательности действий:
  
     1. Произвести загрузку каскадного детектора из файла, с помощью метода `load`
        класса [`cv::CascadeClassifier`][cascade-documentation].
     1. Обработать возможные ошибки при загрузке детектора 
        и вернуть `true` при успешной загрузке, иначе `false`.
  
  1. Реализовать метод `CascadeDetector::Detector`. Метод предполагает
     выполнение следующей последовательности действий:
     
     1. Проверить был ли загружен детектор из файла ранее.
     1. Если детектор был загружен, то осуществить детектирование
        объектов на пирамиде изображений с использованием метода
        `cv::CascadeClassifier::detectMultiScale`.
     1. В качестве значения параметра `score` вернуть число срабатываний детектора,
        пришедшихся на один объект.

  1. Проверить, что после добавления класса `CascadeClassifier` проект по-прежнему
     компилируется.
  1. Сделать копию файла `samples\template_demo.cpp` под именем `samples\detection_demo.cpp`.
     Перегенерируйте решение с помощью CMake, чтобы среди проектов появился новый
     проект `detection_demo`.
  1. Разработать приложение `samples\detection_demo.cpp` в соответствии
     с требованиями, перечисленными в основных задачах.
     
     1. Создать массив опций приложения: `image` - путь до исходного
        изображения; `video` - путь до исходного видеофайла;
        `camera` - идентификатор камеры, с которой требуется получить видеопоток;
        `model` - путь до файла детектора. Опции `image`, `video` и `camera`
        взаимоисключающие, поэтому предлагается наращивать функционал постепенно,
        начиная с поддержки детектирования на изображении.

     ```cpp
     const char* kOptions =
        "{ i image        | <none> | image to process                         }"
        "{ v video        | <none> | video to process                         }"
        "{ c camera       | <none> | camera to get video from                 }"
        "{ m model        | <none> | path to detector file                    }"
        "{ h ? help usage |        | print help message                       }";
     ```

     1. Создать экземпляр класса `CascadeDetector` и загрузить детектор из файла.

     1. Загрузить изображение/очередной кадр видео и выполнить детектирование на нем.

     1. Отрисовать все срабатывания детектора в виде прямоугольников
        на изображении и отобразить результат.
     
     Примечания:

     - Для загрузки изображения используйте функцию [`imread`][imread] библиотеки OpenCV.
     - Для работы с видео используйте класс [`VideoCapture`][video-capture] библиотеки OpenCV.
     - Для отображения изображения используйте функции [`namedWindow`,
       `imshow`, `waitKey`][show-image] модуля `highgui` библиотеки OpenCV.
     - Для отрисовки прямоугольника на изображении используйте функцию
       [`rectangle`][draw-rectangle] модуля `imgproc`.

  1. Загрузить один из готовых детекторов из директории
     `data/detection/cascades/` и визуально оценить качество его работы на
     тестовом видео (`data/video/logo.mp4`) или/и видео с веб-камеры.
     Также можно протестировать готовые модели для детектирования лиц/людей,
     которые предоставляются в составе библиотеки OpenCV
     (`<source-каталог OpenCV>/data/*cascades/`).
     
     Примечание: для запуска приложения необходимо использовать командную
     строку, формат которой приведен ниже.
     ```bash
     $ ./detection_demo.exe -d="<detector-type>" -m="<path-to-xml>" ...
     # <detector-type> - detector type (takes value "cascade")
     # <path-to-xml> - path to model (`data\detection\cascades\*.xml`).
     ```

  1. Поочередно обучить детекторы на LBP- и HAAR-признаках для одного из логотипов
     из директории `data/detection/positives`.

     1. Скопировать папку `data/detection/negatives/`
        и файл `data/detection/negatives.txt` в текущую рабочую директорию.

     1. Запустить приложение `opencv_traincascade` из состава OpenCV
        (`<build-каталог OpenCV>/bin/opencv_traincascade` или 
        `<build-каталог OpenCV>/x64/vc*/bin/opencv_traincascade`), указав следующие параметры:

        * `-vec <путь до vec-файла с позитивными примерами>`.
          Готовые vec-файлы c 2000 позитивов для некоторых логотипов можно найти в
          директории `data/detection/vec_files/`.

        * `-numPos <кол-во позитивов для тренировки>`.

        * `-bg <путь до файла со списком негативных изображений>`. Файл `negatives.txt`
          как раз и содержит такой список.

        * `-numNeg <кол-во негативов для тренировки>`.

        * `-featureType <тип используемых признаков>`. Выберите HAAR или LBP.

        * `-data <путь до директории для сохранения полученного детектора>`.
          Директорию требуется создать заранее!

        * `-w <ширина объекта в пикселях> -h <высота объекта в пикселях>`.
          Так задается минимальный размер детектируемого объекта.

        * `-numStages <максимальное кол-во стадий каскада>`.

        * `-maxFalseAlarmRate <максимально допустимая частота ложных срабатываний>`.


     ```bash
     $ opencv_traincascade -vec logo.vec -numPos 500 -bg negatives.txt -numNeg 500 -featureType HAAR -maxFalseAlarmRate 0.1 -numStages 5 -w 32 -h 32 -data logo_cascade
     ```

        Замечание: работа данного приложения может занять несколько минут
        и время может существенно меняться в зависимости 
        от указанных значений параметров.

  1. Сгенерировать vec-файл для выбранного лого самостоятельно
     и повторить обучение детектора. Для генерации vec-файла
     предназначено приложение `opencv_createsamples`
     (`<build-каталог OpenCV>/bin/opencv_createsamples` или
     `<build-каталог OpenCV>/x64/vc*/bin/opencv_createsamples`).
     Данное приложение позволяет сгенерировать выборку позитивных изображений
     путем применения случайных геометрических преобразований
     и изменения яркости заданного позитивного изображения, а также
     наложения результата на негативное изображение.
     Запуск приложения без параметров приводит к перечислению всех допустимых
     параметров.

  ```bash
  $ opencv_createsamples -img logo.png -bgthresh 1 -bg negatives.txt -maxxangle 0.7 -maxyangle 0.7 -maxzangle 0.5 -num 2000 -w 32 -h 32 -vec logo.vec
  ```
        
  1. Разработать приложения, решающие дополнительные задачи.



<!-- LINKS -->

[opencv]: http://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.1.0/opencv-3.1.0.exe/download
[cmake]: https://cmake.org/download
[git-client]: https://git-scm.com/downloads
[hog-documentation]: http://docs.opencv.org/master/d5/d33/structcv_1_1HOGDescriptor.html
[cascade-documentation]: http://docs.opencv.org/master/d1/de5/classcv_1_1CascadeClassifier.html
[factory-method]: https://sourcemaking.com/design_patterns/factory_method
[video-capture]: http://docs.opencv.org/master/d8/dfe/classcv_1_1VideoCapture.html
[imread]: http://docs.opencv.org/master/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56
[show-image]: http://docs.opencv.org/2.4/doc/tutorials/introduction/display_image/display_image.html
[draw-rectangle]: http://docs.opencv.org/3.1.0/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9