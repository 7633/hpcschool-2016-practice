# Молодежная научная школа "Высокопроизводительные вычисления, оптимизация и приложения". Трек "Робототехника и компьютерное зрение"

## Лабораторная работа "Детектирование объектов с использованием библиотеки OpenCV"

### Цели

*Цель данной лабораторной работы* состоит в том, чтобы решить одну
из классических задач компьютерного зрения - детектирование объектов -
с использованием средств библиотеки OpenCV. В качестве целевых
объектов для детектирования рассматриваются логотипы ННГУ, OpenCV и Intel.

### Задачи

__Основные задачи__

  1. Разработать приложение, осуществляющее детектирование объектов 
     определенного класса (один из предложенных классов логотипов)
     на одиночном изображении и видео с помощью каскадного классификатора.
  1. Обучить детектор логотипов выбранного класса на основе
     HAAR- и LBP-признаков.
  1. Применить полученные самостоятельно детекторы к тестовому видео.
     Визуально оценить качество детекторов.

__Дополнительные задачи__
  
  1. Разработать приложение, позволяющее детектировать логотипы
     нескольких классов на одном изображении/видео одновременно.
  1. Разработать приложение, осуществляющее детектирование логотипов
     на изображении и видео с помощью HOG-детектора
     (см. документацию [`HOGDescriptor`][hog-documentation]).
  1. Добавить в разработанное приложение возможность оценки качества
     детектирования при наличии файла с описанием истинных положений
     объектов на изображении/кадрах видео.

### Общая схема решения задачи детектирования

Общая схема решения задачи детектирования с использованием машинного обучения
включает два основных этапа.

  1. __Обучение детектора.__ Обучение предполагает выполнение следующих
     действий:

     - Подготовка тренировочных данных - множества положительных
       (содержащих объект) и отрицательных (не содержащих объект) примеров
       изображений.
     - Извлечение признаков из каждого изображения тренировочного набора.
     - Обучение детектора на полученном наборе признаков.
     - Сохранение параметров обученной модели.

  1. __Тестирование детектора.__ Тестирование предполагает выполнение
     следующих действий:

     - Получение изображения, на котором необходимо определить положения
       объектов.
     - Извлечение признаков из полученного изображения. На данном этапе
       используется тот же алгоритм, что и при обучении детектора.
     - Передачи построенных признаков детектору, который принимает решение
       о наличии/отсутствии объекта и его местоположении в системе координат
       изображения.
      
### Требования к программному обеспечению

Для выполнения лабораторной работы требуется наличие следующего
программного обеспечения:

  - Библиотеки: [OpenCV 3.1][opencv].
  - Утилиты: [CMake][cmake] 2.8 и выше.
  - Среда разработки: Microsoft Visual Studio 2015 (под Windows)
    или любая другая среда разработки, для которой CMake способен сгенерировать
    файлы для компиляции.
  - [Git-клиент][git-client] (опционально).

### Структура репозитория

Репозиторий содержит следующие директории и файлы:

  - `include` - заголовочные файлы модулей библиотеки `hpc_2016_logo_detection`.
  - `samples` - примеры использования методов. Изначально директория
    содержит шаблонный пример консольного приложения `template_demo.cpp`.
    Лабораторная работа предполагает разработку собственного приложения,
    обеспечивающего решение задачи детектирования на базе указанного шаблона.
  - `src` - исходные файлы модулей библиотеки `hpc_2016_logo_detection`.
  - `data` - директория, содержащая данные, необходимые для решения задачи:

    - `detection/cascades` - xml-файлы, содержащие обученные модели каскадного
      классификатора для логотипов ННГУ, OpenCV и Intel.
    - `detection/negatives` - негативные изображения.
    - `detection/positives` - позитивные изображения детектируемых логотипов.
    - `detection/vec_files` - vec-файлы, содержащие признаковые описания
    - `negatives.txt` - список негативных изображений.
    - `video/logo.mp4` - видео, содержащее сцены с логотипами.

  - `CMakeLists.txt` - общий файл для сборки проектов с помощью CMake.
  - `README.md` - данный файл.
  - `.gitignore`- перечень директорий/файлов, которые игнорируются системой
    контроля версий.

## Общая структура программного модуля

В лабораторной работе основные задачи решаются на базе программного
модуля `detection` библиотеки `hpc_2016_logo_detection`. Модуль
включает заголовочный файл `include\detection.hpp`
и исходный файл`src\detection.cpp`. Модуль содержит объявление
абстрактного класса `Detector`.

```cpp
class Detector {
 public:
  static std::shared_ptr<Detector> CreateDetector(const std::string& name);
  virtual bool Init(const std::string& model_file_path) = 0;
  virtual void Detect(const cv::Mat& frame, std::vector<cv::Rect>& objects,
                      std::vector<double>& scores) = 0;
};
```

Класс имеет следующие чисто виртуальные методы:

  1. `Init` - метод загрузки детектора из файла.
  1. `Detect` - метод детектирования объектов на одиночном изображении.
     Входные параметры: `frame` - изображение.
     Выходные параметры: `objects` - вектор прямоугольников,
     выделяющих найденные объекты на изображении;
     `scores` - вектор, содержащий для каждого срабатывания детектора число,
     определяющее уверенность детектора в наличии объекта 
     в соответствующей области изображения.

Также класс содержит [фабричный метод][factory-method] `CreateDetector`.

### Детальная инструкция по выполнению работы

  1. Дополнить заголовочный файл `include\detection.hpp` объявлением 
     класса `CascadeDetector`, унаследовав его от класса `Detector`.

  ```cpp
  class CascadeDetector : public Detector {
   public:
    virtual bool Init(const std::string& model_file_path);
    virtual void Detect(const cv::Mat& frame, std::vector<cv::Rect>& objects,
                        std::vector<double>& scores);

   protected:
    cv::CascadeClassifier detector;
  };
  ```

  1. Добавить код для создания экземпляра класса `CascadeDetector` в фабричный метод
     `Detector::CreateDetector`.

  ```cpp
  if (name == "cascade") {
    return std::make_shared<CascadeDetector>();
  }
  ```

  1. Реализовать метод `CascadeDetector::Init`. Метод предполагает
     выполнение следующей последовательности действий:
  
     1. Произвести загрузку каскадного детектора из файла, с помощью метода `load`
        класса [`cv::CascadeClassifier`][cascade-documentation].
     1. Обработать возможные ошибки при загрузке детектора 
        и вернуть `true` при успешной загрузке, иначе `false`.
  
  1. Реализовать метод `CascadeDetector::Detector`. Метод предполагает
     выполнение следующей последовательности действий:
     
     1. Проверить был ли загружен детектор из файла ранее.
     1. Если детектор был загружен, то осуществить детектирование
        объектов на пирамиде изображений с использованием метода
        `cv::CascadeClassifier::detectMultiScale`.
     1. В качестве значения параметра `score` вернуть число срабатываний детектора,
        пришедшихся на один объект.

  1. Сделать копию файла `samples\template_demo.cpp` под именем `samples\detection_demo.cpp`.
  1. Разработать приложение `samples\detection_demo.cpp` в соответствии
     с требованиями, перечисленными в основных задачах.
     
     1. Создать массив опций приложения: `image` - путь до исходного
        изображения; `video` - путь до исходного видеофайла;
        `camera` - идентификатор камеры, с которой требуется получить видеопоток;
        `model` - путь до файла детектора.
        Опции `image`, `video` и `camera` взаимоисключающие.

     ```cpp
     const char* kOptions =
        "{ i image        | <none> | image to process                         }"
        "{ v video        | <none> | video to process                         }"
        "{ c camera       | <none> | camera to get video from                 }"
        "{ m model        | <none> | path to detector file                    }"
        "{ h ? help usage |        | print help message                       }";
     ```

     1. Создать экземпляр класса `CascadeDetector` и загрузить детектор из файла.

     1. Загрузить изображение/очередной кадр видео и выполнить детектирование на нем.

     1. Отрисовать все срабатывания детектора в виде прямоугольников
        на изображении и отобразить результат.

  1. Загрузить один из готовых детекторов из директории
     `test/test_data/detection/cascades/` и визуально оценить качество его работы на
     тестовом видео (`test/test_data/video/logo.mp4`) или/и видео с веб-камеры.
     Также можно протестировать готовые модели для детектирования лиц/людей,
     которые предоставляются в составе библиотеки OpenCV
     (`<source-каталог OpenCV>/data/*cascades/`).

  1. Поочередно обучить детекторы на LBP- и HAAR-признаках для одного из логотипов
     из директории `test/test_data/detection/positives`.

     1. Скопировать папку `test/test_data/detection/negatives/`
        и файл `test/test_data/detection/negatives.txt` в текущую рабочую директорию.

     1. Запустить приложение `opencv_traincascade` из состава OpenCV
        (`<build-каталог OpenCV>/bin/opencv_traincascade` или 
        `<build-каталог OpenCV>/x64/vc*/bin/opencv_traincascade`), указав следующие параметры:

        * `-vec <путь до vec-файла с позитивными примерами>`.
          Готовые vec-файлы c 2000 позитивов для некоторых логотипов можно найти в
          директории `test/test_data/detection/vec_files/`.

        * `-numPos <кол-во позитивов для тренировки>`.

        * `-bg <путь до файла со списком негативных изображений>`. Файл `negatives.txt`
          как раз и содержит такой список.

        * `-numNeg <кол-во негативов для тренировки>`.

        * `-featureType <тип используемых признаков>`. Выберите HAAR или LBP.

        * `-data <путь до директории для сохранения полученного детектора>`.
          Директорию требуется создать заранее!

        * `-w <ширина объекта в пикселях> -h <высота объекта в пикселях>`.
          Так задается минимальный размер детектируемого объекта.

        * `-numStages <максимальное кол-во стадий каскада>`.

        * `-maxFalseAlarmRate <максимально допустимая частота ложных срабатываний>`.


     ```bash
     $ opencv_traincascade -vec logo.vec -numPos 500 -bg negatives.txt -numNeg 500 -featureType HAAR -maxFalseAlarmRate 0.1 -numStages 5 -w 32 -h 32 -data logo_cascade
     ```

        Замечание: работа данного приложения может занять несколько минут
        и время может существенно меняться в зависимости 
        от указанных значений параметров.

  1. Сгенерировать vec-файл для выбранного лого самостоятельно
     и повторить обучение детектора. Для генерации vec-файла
     предназначено приложение `opencv_createsamples`
     (`<build-каталог OpenCV>/bin/opencv_createsamples` или
     `<build-каталог OpenCV>/x64/vc*/bin/opencv_createsamples`).
     Данное приложение позволяет сгенерировать выборку позитивных изображений
     путем применения случайных геометрических преобразований
     и изменения яркости заданного позитивного изображения, а также
     наложения результата на негативное изображение.
     Запуск приложения без параметров приводит к перечислению всех допустимых
     параметров.

  ```bash
  $ opencv_createsamples -img logo.png -bgthresh 1 -bg negatives.txt -maxxangle 0.7 -maxyangle 0.7 -maxzangle 0.5 -num 2000 -w 32 -h 32 -vec logo.vec
  ```
        
  1. Разработать приложения, решающие дополнительные задачи.



<!-- LINKS -->

[opencv]:http://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.1.0/opencv-3.1.0.exe/download
[cmake]:https://cmake.org/download
[git-client]:https://git-scm.com/downloads
[hog-documentation]: http://docs.opencv.org/master/d5/d33/structcv_1_1HOGDescriptor.html
[cascade-documentation]: http://docs.opencv.org/master/d1/de5/classcv_1_1CascadeClassifier.html
[factory-method]: https://sourcemaking.com/design_patterns/factory_method